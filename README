Apodora Python run time

-----

INSTALL:

From root:
 python setup.py build
 cp build/lib.platform/asmhelper.(so|pdy|dll) src


From src:
 python entry.py
 python entry.py ../tests/test0.py

-----

HOW THIS THING WORKS:

Startup (in the compiler):

- malloc module address -> static address

In Running Code (in the assembly):

- Module Startup

 - malloc module
 - set __layout__ 
 - store &module in static address for module

- Add a global 

 - malloc new module
 - copy memory from old to new
 - set new __layout__
 - store &module in static address for module

- Read a global

 - Check cached internal class with current __layout__
 - if same:
  - load offset
 - else:
  - offset = __compiler__.get_offset(module,name)
  - __compiler__.fixup_inline_cache(module,module.__layout__,offset)
 - read from offset

-------

Where things go:

- Syntatic things in the SyntaxWalker
- SyntaxWalker calls SemanticList with Semantic Ops 
- SemanticList -> Calls ops in the Assembler
- Assembly and Linking in the Assembler

- Inline intrinsics implemented in the SemanticList as functions, available as static functions on __intrinsic__
- Functional intrinsics implemented in lib/__compiler__.py, available as static functions on __compiler__


------------

Layout Objects
- Size of everything in x64 is 64bit

size_t size
name_type_hash last_add
pointer prev_layout
pointer add_list




